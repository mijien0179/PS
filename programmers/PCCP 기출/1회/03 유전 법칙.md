[03 유전 법칙](https://school.programmers.co.kr/learn/courses/15008/lessons/121685)

```cpp
#include <string>
#include <vector>
#include <cmath>

using namespace std;

string dna[] = {"RR","Rr","Rr","rr"};

string recursion(int gen, int preOrder){ // preOrder = 전처리 된 순서
    if(gen == 1) return "Rr";               // LINE 10
    
    if(gen == 2) return dna[preOrder];
    
    long quarterSize = pow(4, gen - 2);
    long maximumSize = quarterSize << 2;
    
    int branch = preOrder / quarterSize;
    
    switch(branch){
        case 0: return "RR";
        case 3: return "rr";
            // 위 return 문 두개를 지우고
            // return dna[branch]; // 로 구성할 수도 있다.
        case 1:
        case 2:
            return recursion(gen-1, preOrder - (quarterSize << (branch-1)));
    }
    
}

vector<string> solution(vector<vector<int>> queries) {
    vector<string> answer;
    
    for(auto& query: queries){
        answer.emplace_back(recursion(query[0], query[1]-1));   // LINE 34
    }
    
    return answer;
}
```

재귀로 구성한 내용.
기본 구성은 \[RR, Rr, Rr, rr]의 재귀형태이나, 예외적으로 gen-1은 단일 `Rr`이기에 코드의 LINE 10에서 별도 사항으로 예외처리 했다.  
기본 구성은 gen-2에 존재하므로, gen == 2인 경우 dna(array, string)의 값을 주도록 하였다.  

부모 세대를 `A`, 자식 세대를  `B`라 할때, B 세대의 종자 수는 A 세대 종자 수의 4배이다.  
이는 곧, A 세대에 존재하는 각각의 종자에서 4개의 자식 종자가 발생한다는 것을 의미한다.  
찾고자 하는 B 세대의 순서값(preOrder)를 부모 세대 A의 전체 종자 수로 나누면 어떤 유전 인자를 가지는 부모에서 발생한 종자인지 파악할 수 있다.  
이때 나눈 값의 범위는 0-3`branchNumber`만을 가진다.
여기에서, 부모 세대 `RR`과 `rr`에서는 부모세대의 dna와 일치하는 유전인자만을 가질 수 있으므로 branch 0, branch 3은 각각 부모 종자의 인자를 바로 보내도록 했다.

또한, branch 1과 2는 모양이 같은 유전인자를 가진다. 찾고자 하는 종자의 순서에서 `quarterSize * branchNumber`만큼의 값을 빼주면 바로 윗 부모 종자 세대의 순서와 일치하게 되는 성격을 가진다.  
따라서 재귀 구성에서 `recursion(gen - 1, preOrder - quarterSize * branchName)`으로 호출하게 되면 순차적으로 상위 종자에서 찾게된다.
